---
title: Rust 优化JS工具函数落地尝试
date: 2024-12-14T03:18:26Z
slug: post-1
author: chenwll：https://github.com/chenwll
tags: ["Rust"]
---

<p class="p1"><b>一. 前言</b></p>
<p class="p2">由于 Rust 作为一种系统编程语言，其在性能、安全性和并发处理方面有着诸多优势。在某些领域正逐步被用来补充或者增强前端工具链。</p>
<ul class="ul1">
<li class="li2"><span class="s1"></span>性能：Rust 被设计为一种系统级编程语言，具有非常接近 C 或 C++的性能。这对于前端工具链（如模块打包器、编译器等），特别是那些需要高性能计算的工具链来说，是非常有益的。</li>
<li class="li2"><span class="s1"></span>类型安全：Rust 具有强类型系统，并在编译时强制进行类型检查。与之相比，JavaScript 是一种弱类型语言，类型错误可能只有在运行时才能被发现。</li>
<li class="li2"><span class="s1"></span>内存安全： Rust 通过其独特的所有权和借用机制，在编译阶段有效避免了空指针解引用及数据竞争等潜在问题。</li>
</ul>
<p class="p2">由于 Rust 独特优势，也激发了一类新的工具们的诞生，提高了 web 构建的效率</p>
<ul class="ul1">
<li class="li2"><span class="s1"><a href="https://github.com/volta-cli/volta"><span class="s2">volta</span></a></span>：对标 npm + nvm</li>
<li class="li2"><span class="s1"></span>postcss-rs：对标 postcss</li>
<li class="li2"><span class="s1"></span>swc：代替 babel</li>
<li class="li2"><span class="s1"></span>Rspack：代替 webpack</li>
<li class="li2"><span class="s1"></span>Biome: 代替 eslint 和 prettier</li>
</ul>
<p class="p1"><b>二. 技术调研</b></p>
<p class="p2">除了使用上述的构建工具，我们也可通过 Rust 来优化自己的工具函数。因为大部分前端研发都是在 Node 环境下进行的，主要有两种形式：</p>
<ul class="ul1">
<li class="li2"><span class="s1"></span>使用 WASM 的方式，基于<a href="https://link.juejin.cn/?target=https%3A%2F%2Frustwasm.github.io%2Fwasm-pack%2F"><span class="s3">wasm-pack</span></a>，将 Rust 代码编译成 WASM，以供 Node 调用</li>
<li class="li2"><span class="s1"></span>将 Rust 应用编译成 Node addons，通过 Node API 的方式供 Node 调用，可以基于<a href="https://link.juejin.cn/?target=https%3A%2F%2Fnapi.rs%2F"><span class="s3">napi-rs</span></a> 来实现</li>
</ul>
<p class="p2">在这两种方式的选择上，主要取决于你是否需要完整地访问 Node API，WASM 出于安全性的考虑，对于 Node 能力的调用存在限制，那么你就应该选择 Node addons 的方式了。</p>
<p class="p1"><b>基于 WASM</b></p>
<p class="p1"><b>1.1 WASM 定义</b></p>
<p class="p2">WebAssembly（缩写为 wasm）是一种使用非 JavaScript 代码，并使其在浏览器中运行的方法。这些代码可以是 C、C++ 或 Rust 等。它们会被编译进你的浏览器，在你的 CPU 上以接近原生的速度运行。这些代码的形式是二进制文件，你可以直接在 JavaScript 中将它们当作模块来用。</p>
<p class="p3"><br></p>
<p class="p2">上图的左侧是用 C++实现的求递归的函数。中间是十六进制 的 Binary Code。右侧是指令文本。其实，中间的十六进制的 Binary Code 就是 WebAssembly。</p>
<p class="p2">总结：</p>
<ul class="ul1">
<ul class="ul1">
<li class="li2"><span class="s1"></span>WASM 是一种<b>编译目标</b>，不是用来给各位用手一行一行撸的代码， C、C++ 或 Rust 等都可以编译 成 WASM</li>
<li class="li2"><span class="s1"></span>WASM 模块可以被导入的到一个 Web / Node 中，并且暴露出供 JavaScript 使用的 WebAssembly 函数。</li>
</ul>
</ul>
<p class="p1"><b>1.2 Rust 如何编译成 WASM</b></p>
<p class="p1"><b>1.2.1 wasm-pack</b></p>
<p class="p2"><span class="s3"><a href="https://github.com/rustwasm/wasm-pack">wasm-pack</a></span>是一个构建、测试和发布 WASM 的 Rust CLI 工具，通过 wasm-pack 相关的命令可以管理构建过程，包括自动调用 wasm-bindgen 来生成胶水代码。</p>
<p class="p2">wasm-pack build --target nodejs</p>
<p class="p2">wasm-pack 会在项目中创建一个 pkg 目录，并包含以下内容</p>
<ul class="ul1">
<ul class="ul1">
<li class="li2"><span class="s1"></span>js 文件</li>
<li class="li2"><span class="s1"></span>wasm 文件</li>
<li class="li2"><span class="s1"></span>ts 声明文件</li>
<li class="li2"><span class="s1"></span>package.json 文件，所以打包出来的包是可以直接发 布 n pm 的</li>
<li class="li2"><span class="s1"></span>README 文件，是从你 的 Ru st 项 目中的 RE ADME 文件复制来的</li>
</ul>
</ul>
<p class="p3"><br></p>
<p class="p1"><b>1.3 JS 如何调用 WASM</b></p>
<p class="p2">通过<a href="https://rustwasm.github.io/wasm-pack/installer/"><span class="s3">wasm-pack</span></a> 将 Rust 打包成可发布的 npm 包，js 通过调用 npm package 来调用编译好的 wasm 模块</p>
<p class="p3"><br></p>
<p class="p1"><b>1.4 JS 和 Rust 交互</b></p>
<p class="p2">主要从 JS 如何调用 Rust 函数、数据交互两方面介绍</p>
<p class="p1"><b>1.4.1 JS 调用 Rust 函数</b></p>
<p class="p2"><span class="s3"><a href="https://github.com/rustwasm/wasm-bindgen"><b>wasm-bindgen</b><b></b></a></span></p>
<p class="p2"><span class="s3"><a href="https://github.com/rustwasm/wasm-bindgen">wasm-bindgen</a></span>可以让WASM模块和Javascript模块进行更好的交互。通过使用宏（如 #[wasm_bindgen]）来注解Rust代码，这些宏会指导 wasm-bindgen 工具生成必要的JS胶水代码（glue code），以便Rust函数可以作为JavaScript函数来调用，或允许Rust代码调用JavaScript函数。</p>
<p class="p2">use wasm_bindgen::prelude::*;</p>
<p class="p3"><br></p>
<p class="p2">// 从Web导入 `window.alert` 函数</p>
<p class="p2">#[wasm_bindgen]</p>
<p class="p2">extern "C" {</p>
<p class="p2"><span class="Apple-converted-space">    </span>fn alert(s: &amp;str);</p>
<p class="p2">}</p>
<p class="p3"><br></p>
<p class="p2">// 从Rust导出一个`greet`函数到Javascript，该函数会`alert`一条欢迎信息</p>
<p class="p2">#[wasm_bindgen]</p>
<p class="p2">pub fn greet(name: &amp;str) {</p>
<p class="p2"><span class="Apple-converted-space">    </span>alert(&amp;format!("Hello, {}!", name));</p>
<p class="p2">}</p>
<p class="p1"><b>1.4.2 数据交互</b></p>
<p class="p2">js调用Rust函数进行函数传参时，我们需要通过json来处理，就需要用到serde和serde_json两个包</p>
<p class="p2"><span class="s3"><a href="https://www.rectcircle.cn/posts/rust-serde/"><b>Serde</b><b></b></a></span></p>
<p class="p2">Serde 是一个用于高效、通用地对 Rust 数据结构<i>ser</i>ializing(进行序列化)和<i>de</i>serializing(反序列化)的框架。该包提供了Serialize和Deserialize 两个trait。它本身不做转换的实际工作，实际工作是其它包实现的。我们可以结合serde，通过serde_json和rmp-serde将一种数据格式转换成JSON和MessagePack格式。</p>
<p class="p2"><b>Serde_json</b></p>
<p class="p2">serde_json 是 serde 的一个插件，它提供了对 JSON 格式的支持。你可以使用 serde_json 将 JSON 数据反序列化为 Rust 数据结构，或者将 Rust 数据结构序列化为 JSON 格式。</p>
<p class="p2">serde_json = {version = "1", features = ["preserve_order"]}</p>
<p class="p2">serde = "1"</p>
<p class="p2">在 serde_json 中开启【preserve_order】这个 features，是因为 serde_json 在处理 json 数据时，Map 默认使用的是 BtreeMap，它对插入顺序不保证</p>
<p class="p2">// source是一个读取后json文件的信息</p>
<p class="p3"><br></p>
<p class="p2">#[wasm_bindgen]</p>
<p class="p2">pub fn replace_json(source: &amp;str, config: &amp;str) -&gt; String {</p>
<p class="p2"><span class="Apple-converted-space">    </span>let mut json_value: Map&lt;String, Value&gt; = serde_json::from_str(source).unwrap();</p>
<p class="p2"><span class="Apple-converted-space">    </span>let replacer = ConstReplacer::new(config);</p>
<p class="p2"><span class="Apple-converted-space">    </span>// 更新Json</p>
<p class="p2"><span class="Apple-converted-space">    </span>json_value[replacer.replaced_name] = replacer.replaced_value;</p>
<p class="p3"><br></p>
<p class="p2"><span class="Apple-converted-space">      </span>// 将更新后的 json 结构体重新转换回 json 字符串</p>
<p class="p2"><span class="Apple-converted-space">    </span>let updated_json = serde_json::to_string_pretty(&amp;json_value).unwrap();</p>
<p class="p2"><span class="Apple-converted-space">    </span>updated_json</p>
<p class="p2">}</p>
<p class="p2">如果想要让修改后JSON中的key顺序保持不变，那可以开启 preserve_order 特性</p>
<p class="p2">#[cfg(not(feature = "preserve_order"))]</p>
<p class="p2">type MapImpl&lt;K, V&gt; = BTreeMap&lt;K, V&gt;;</p>
<p class="p2">#[cfg(feature = "preserve_order")]</p>
<p class="p2">type MapImpl&lt;K, V&gt; = IndexMap&lt;K, V&gt;;</p>
<p class="p1"><b>基于 Node addons</b></p>
<p class="p1"><b>2.1 Nodejs addon 定义</b></p>
<p class="p2">node addon，即为 node 的扩展。</p>
<p class="p2">我们知道，Node.js 不适合 CPU 密集型计算的场景，通常的解决方法是用 C/C++ 编写 Node.js 的扩展（Addons）。以前只能用 C/C++，但是现在我们也可通过 Rus t 来编写我 们的 n ode 扩展。</p>
<ul class="ul1">
<ul class="ul1">
<li class="li2"><span class="s1"></span>.node结尾的文件</li>
<li class="li2"><span class="s1"></span>是一个二进制文件</li>
<li class="li2"><span class="s1"></span>是一个动态链接库 (Windows dll/Linux so/Unix dylib)</li>
</ul>
</ul>
<p class="p3"><br></p>
<p class="p1"><b>2.2 使用</b><a href="https://napi.rs/"><span class="s3"><b>napi.rs</b></span></a><b> 编写 node addons</b></p>
<p class="p2">napi-rs 是一个使用 Rust 构建预编译 Nodejs 插件的框架 ，通过这个框架我们可以使 用 Rust 来编写我们自己的原生 Nodejs 插件。</p>
<p class="p2">// 安装脚手架</p>
<p class="p2">yarn global add @napi-rs/cli</p>
<p class="p3"><br></p>
<p class="p2">// 创建项目</p>
<p class="p2">napi new</p>
<p class="p3"><br></p>
<p class="p2">// 构建</p>
<p class="p2">yarn build</p>
<p class="p2">build 完之后会新建三个文件</p>
<ul class="ul1">
<ul class="ul1">
<li class="li2"><span class="s1"></span>cool.darwin-x64.node是 Node.js addon 二进制文件</li>
<li class="li2"><span class="s1"></span>index.js自动生成的 JavaScript 绑定文件，它帮你从 addon 二进制中 export 出所有的东西，并且保证对 esm 与 CommonJS 的兼容。</li>
<li class="li2"><span class="s1"></span>index.d.ts是生成的 TypeScript 定义文件。</li>
</ul>
</ul>
<p class="p3"><br></p>
<p class="p2">index.js这个入口文件会根据操作系统和 CPU 架构来加载不同的二进制文件</p>
<p class="p1"><b>2.3 js如何使用node addons</b></p>
<p class="p2">由于 napi-rs 已经帮助我们初始化了 CI 脚本，当你往 main 分支提交代码时，会自动触发 GitHub Actions 的操作，执行构建、测试、发布等步骤。</p>
<p class="p2">值得注意的是，在默认的脚本中，会根据当前的 commit 信息来判断是否需要发布，具体的判断逻辑如下:</p>
<ul class="ul1">
<ul class="ul1">
<li class="li2"><span class="s1"></span>case 1: 如果当前的 commit 信息只有 x.x.x(x 为数字)，则发布正式版本到 npm 上</li>
<li class="li2"><span class="s1"></span>case 2: 如果当前的 commit 信息在 case 1 的基础上增加了一些后缀内容，则发布 beta 版本到 npm 上</li>
<li class="li2"><span class="s1"></span>其它情况不会发布。</li>
</ul>
</ul>
<p class="p2">在开发阶段和生产环境下调用node addons的策略有所不同</p>
<ul class="ul1">
<ul class="ul1">
<li class="li2"><span class="s1"></span>本地开发阶段：直接通过yarn build，生成对应操作系统下的.node文件，然后加载项目目录下的.node文件</li>
<li class="li2"><span class="s1"></span>生成环境：</li>
</ul>
</ul>
<p class="p2">暴露给用户安装使用的 package 将所有的 native package 作为optionalDependencies，然后通过package.json中的os与cpu字段，让npm/yarn/pnpm在安装的时候<b>自动选择(其实是不符合系统要求的就安装失败了)</b>安装哪一个 native package，比如</p>
<p class="p2">{</p>
<p class="p2"><span class="Apple-converted-space">  </span>"name": "@cwl/const-replace",</p>
<p class="p2"><span class="Apple-converted-space">  </span>"version": "0.5.0",</p>
<p class="p2"><span class="Apple-converted-space">  </span>"os": ["linux", "win32", "darwin"],</p>
<p class="p2"><span class="Apple-converted-space">  </span>"cpu": ["x64"],</p>
<p class="p2"><span class="Apple-converted-space">  </span>"optionalDependencies": {</p>
<p class="p2"><span class="Apple-converted-space">    </span>"@cwl/const-replace-darwin": "^0.5.0",</p>
<p class="p2"><span class="Apple-converted-space">    </span>"@cwl/const-replace-linux": "^0.5.0",</p>
<p class="p2"><span class="Apple-converted-space">    </span>"@cwl/const-replace-win32": "^0.5.0"</p>
<p class="p2"><span class="Apple-converted-space">  </span>}</p>
<p class="p2">}</p>
<p class="p2">{</p>
<p class="p2"><span class="Apple-converted-space">  </span>"name": "@cwl/const-replace-darwin",</p>
<p class="p2"><span class="Apple-converted-space">  </span>"version": "0.5.0",</p>
<p class="p2"><span class="Apple-converted-space">  </span>"os": ["darwin"],</p>
<p class="p2"><span class="Apple-converted-space">  </span>"cpu": ["x64"]</p>
<p class="p2">}</p>
<p class="p2">{</p>
<p class="p2"><span class="Apple-converted-space">  </span>"name": "@cwl/const-replace-linux",</p>
<p class="p2"><span class="Apple-converted-space">  </span>"version": "0.5.0",</p>
<p class="p2"><span class="Apple-converted-space">  </span>"os": ["linux"],</p>
<p class="p2"><span class="Apple-converted-space">  </span>"cpu": ["x64"]</p>
<p class="p2">}</p>
<p class="p2">比如我们将包发布到 npm 后，当用户执行 yarn add @cwl/const-replace 时，会自动下载 @cwl/const-replace-darwin-arm64 这个包，这个包里面包含了编译好的二进制文件，也就是 const-replace.darwin-arm64.node。这时候入口文件会去加载这个包里面的二进制文件。</p>
<p class="p3"><br></p>
<p class="p2">esbuild中就采用了上述的分发模式<a href="https://github.com/evanw/esbuild/blob/332727499e62315cff4ecaff9fa8b86336555e46/npm/esbuild/package.json#L20"><span class="s3">https://github.com/evanw/esbuild/blob/332727499e62315cff4ecaff9fa8b86336555e46/npm/esbuild/package.json#L20</span></a></p>
<p class="p3"><br></p>
<p class="p1"><b>WASM 和 Node addons 对比</b></p>
<p class="p1"><b>3.1 跨平台</b></p>
<p class="p2">WebAssembly 设计为一个通用的二进制格式，可以在任何支 持 WebAssembly 的平台上运行 ，包括 Web 浏览器和 Node.js 环境。WASM 模块编译一次，可以在几乎所有操作系统和硬件架构上运行。</p>
<p class="p2">napi-rs 天然不支持跨平台，它需要根据不同平台构建出不同的二进制文件。如果需要支持跨平台应用的话，需要集成跨平台的流水线。</p>
<p class="p3"><br></p>
<p class="p2">为了加载正确二进制文件，napi.rs会尝试加载该平台下所有可能的包</p>
<p class="p2">switch (platform) {</p>
<p class="p2"><span class="Apple-converted-space">  </span>case "android":</p>
<p class="p2"><span class="Apple-converted-space">    </span>// ...</p>
<p class="p2"><span class="Apple-converted-space">    </span>break;</p>
<p class="p2"><span class="Apple-converted-space">  </span>case "win32":</p>
<p class="p2"><span class="Apple-converted-space">    </span>// ...</p>
<p class="p2"><span class="Apple-converted-space">    </span>break;</p>
<p class="p2"><span class="Apple-converted-space">  </span>case "darwin":</p>
<p class="p2"><span class="Apple-converted-space">    </span>// ...</p>
<p class="p2"><span class="Apple-converted-space">    </span>break;</p>
<p class="p2"><span class="Apple-converted-space">  </span>default:</p>
<p class="p2"><span class="Apple-converted-space">    </span>throw new Error(`Unsupported OS: ${platform}, architecture: ${arch}`);</p>
<p class="p2">}</p>
<p class="p1"><b>3.2 性能</b></p>
<p class="p2">Rust 原生 ≈ NativeAddon &gt; WASM &gt; JavaScript</p>
<p class="p2">以斐波那契数列为例：</p>

n/耗时 | Rust 原生 | Native Addon | WASM | JS
-- | -- | -- | -- | --
43 | 0.97s | 1.1s | 2.9s | 3.3s
44 | 1.55s | 1.6s | 4.6s | 5.3s
45 | 2.5s | 2.5s | 7.4s | 8.5s


<p class="p2">结论：采用方案二，先以最小成本验证Rust优化js工具函数的可行性。若后续能力需扩充可采用node addons的方式，逻辑和代码均可复用</p>
<p class="p1"><b>具体实现</b></p>
<p class="p2">尝试搭建一个 Rust 项目，通过 serde_json 处理数据交互，swc/core 进行 AST 语法分析，wasm-pack 进行 Rust 项目的打包，具体步骤如下：</p>
<p class="p2">a. 创建项目</p>
<p class="p2">cargo new --lib const_replace</p>
<ul class="ul1">
<ul class="ul1">
<li class="li2"><span class="s1"></span>因为我们要编译成wasm供js调用，需要将crate-type改成cdylib</li>
</ul>
</ul>
<p class="p2">[lib]</p>
<p class="p2">crate-type = ["cdylib"]</p>
<ul class="ul1">
<ul class="ul1">
<li class="li2"><span class="s1"></span>引入swc_core，通过遍历ast，进行变量的修改</li>
</ul>
</ul>
<p class="p2">cargo add swc_core --features common,ecma_ast,ecma_parser,ecma_visit,ecma_codegen</p>
<p class="p2">swc 中核心库及作用如下：<a href="https://rustdoc.swc.rs/swc_core/index.html#"><span class="s3">swc_core - Rust</span></a>swc 中核心库及作用如下：<a href="https://rustdoc.swc.rs/swc_core/index.html#"><span class="s3">swc_core - Rust</span></a></p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<ul class="ul1">
<ul class="ul1">
<li class="li2"><span class="s1"></span>因为 js 需要通过 json 传参给 wasm，在 Rust 中需要引入 serde,serde_json 来解析 json</li>
</ul>
</ul>
<p class="p2">serde_json = {version = "1", features = ["preserve_order"]}</p>
<p class="p2">serde = "1"</p>
<ul class="ul1">
<ul class="ul1">
<li class="li2"><span class="s1"></span>我们需要让 wasm 和 js 进行交互，需要引入<a href="https://github.com/rustwasm/wasm-bindgen"><span class="s3">wasm-bindgen</span></a></li>
</ul>
</ul>
<p class="p2">wasm-bindgen = "0.2.83"</p>
<ul class="ul1">
<ul class="ul1">
<li class="li2"><span class="s1"></span>将需要导出的函数添加#[wasm_bindgen]过程宏，wasm-bindgen在编译时会生成对应的 glue code，从而在JS和webassembly之间调用函数</li>
</ul>
</ul>
<p class="p2">extern crate wasm_bindgen;</p>
<p class="p2">use wasm_bindgen::prelude::*;</p>
<p class="p3"><br></p>
<p class="p2">#[wasm_bindgen]</p>
<p class="p2">pub fn const_replace(source: &amp;str, config: &amp;str) -&gt; Result&lt;String, JsError&gt; {</p>
<p class="p2">}</p>
<p class="p2">至此，我们项目所有的依赖如下：</p>
<p class="p2">[package]</p>
<p class="p2">name = "const-replace"</p>
<p class="p2">version = "0.1.0"</p>
<p class="p2">edition = "2021"</p>
<p class="p3"><br></p>
<p class="p2">[lib]</p>
<p class="p2">crate-type = ["cdylib"]</p>
<p class="p3"><br></p>
<p class="p2">[dependencies]</p>
<p class="p2">swc_core = { version = "0.97.5", features = ["common", "ecma_ast", "ecma_parser", "ecma_visit", "ecma_codegen"] }</p>
<p class="p2">serde_json = {version = "1", features = ["preserve_order"]}</p>
<p class="p2">serde = "1"</p>
<p class="p2">wasm-bindgen = "0.2.83"</p>
<ul class="ul1">
<ul class="ul1">
<li class="li2"><span class="s1"></span>通过<a href="https://rustwasm.github.io/wasm-pack/installer/"><span class="s3">wasm-pack</span></a> 将 Rust 打包成可发布的 npm 包，js 通过调用 npm package 来调用编译好的 wasm 模块</li>
</ul>
</ul>
<p class="p2">yarn global add wasm-pack</p>
<p class="p3"><br></p>
<p class="p2">// 因为我们是通过node执行js文件，所以将target设置成nodejs，也可设置成为web</p>
<p class="p2">wasm-pack build --target nodejs</p>
<p class="p3"><br></p>
<p class="p2">// js调用</p>
<p class="p2">const pkg = require('const-replace');</p>
<p class="p2">const content = pkg.const_replace(source, config)</p>
<p class="p1"><b>四. 总结</b></p>
<p class="p1"><b>业务方向</b></p>
<p class="p2">Rust语言的独特优势以及在前端生态能力上的逐渐完善，越来越多的业务场景都用了Rust来扩展我们的JS能力</p>
<p class="p2">厂内：</p>
<ul class="ul1">
<li class="li2"><span class="s1"></span>凤巢前端将调用频次高的热点函数通过Rust实现，通过napi-rs进行打包：</li>
</ul>
<p class="p2"><span class="s3"><a href="https://ku.baidu-int.com/knowledge/HFVrC7hq1Q/MUyZ7Y-BGz/0eHeaiwzQ0/2e74f564f45f46">【2024.03.13】Rust扩展在Node.js中的应用</a></span></p>
<ul class="ul1">
<li class="li2"><span class="s1"></span>利用webassembly的高性能实现特征点检测，虽然它是通过C 来编译成WASM的：</li>
</ul>
<p class="p2"><span class="s3"><a href="https://ku.baidu-int.com/knowledge/HFVrC7hq1Q/5PohCU7HAz/Hb94Bhd9BC/i9_3Le8m7eQ-jf">WEB世界的一扇窗---从一个真实需求看WebAssembly的应用</a></span></p>
<p class="p2">外部：</p>
<ul class="ul1">
<li class="li2"><span class="s1"></span>抖音IM软件重构：<a href="https://juejin.cn/post/7336022842856177690?searchId=20240823012721791F00E88C7EB7B3197B"><span class="s3">Rust语言在IM客户端的实践</span></a></li>
<li class="li2"><span class="s1"></span>京东3D模型计算：<a href="https://juejin.cn/post/7308434321764794378#heading-5"><span class="s3">给 Web 前端工程师看的用 Rust 开发 wasm 组件实战</span></a></li>
<li class="li2"><span class="s1"></span>Rspack 支持 JS 编写 loader 和 plugin (napi-rs)</li>
<li class="li2"><span class="s1"></span>......</li>
</ul>
<p class="p2">当JS执行的性能达到瓶颈时，我们也可以换个角度思考，利用Rust的独特优势来进行优化CPU密集型的任务</p>
<p class="p1"><b>Rust学习感悟</b></p>
<ol class="ol1">
<li class="li5"><span class="s5"></span>多利用<span class="s5">GPT</span>，不懂的代码<span class="s5">/</span>报错可以向<span class="s5">GPT</span>的提问，大部分给的思路和方向都是正确的</li>
<li class="li5"><span class="s5"></span>多在<span class="s5">githhub</span>参考别人的代码，不需要全部看懂，只需要关注部分实现，逻辑打通即可</li>
<li class="li5"><span class="s5"></span>当以上都还没解决你的问题时，尝试在<span class="s5">github</span>相关仓库提问</li>
</ol>
</body>
</html>
一. 前言
由于 Rust 作为一种系统编程语言，其在性能、安全性和并发处理方面有着诸多优势。在某些领域正逐步被用来补充或者增强前端工具链。
* 性能：Rust 被设计为一种系统级编程语言，具有非常接近 C 或 C++的性能。这对于前端工具链（如模块打包器、编译器等），特别是那些需要高性能计算的工具链来说，是非常有益的。
* 类型安全：Rust 具有强类型系统，并在编译时强制进行类型检查。与之相比，JavaScript 是一种弱类型语言，类型错误可能只有在运行时才能被发现。
* 内存安全： Rust 通过其独特的所有权和借用机制，在编译阶段有效避免了空指针解引用及数据竞争等潜在问题。
由于 Rust 独特优势，也激发了一类新的工具们的诞生，提高了 web 构建的效率
* [volta](https://github.com/volta-cli/volta)：对标 npm + nvm
* postcss-rs：对标 postcss
* swc：代替 babel
* Rspack：代替 webpack
* Biome: 代替 eslint 和 prettier
二. 技术调研
除了使用上述的构建工具，我们也可通过 Rust 来优化自己的工具函数。因为大部分前端研发都是在 Node 环境下进行的，主要有两种形式：
* 使用 WASM 的方式，基于[wasm-pack](https://link.juejin.cn/?target=https%3A%2F%2Frustwasm.github.io%2Fwasm-pack%2F)，将 Rust 代码编译成 WASM，以供 Node 调用
* 将 Rust 应用编译成 Node addons，通过 Node API 的方式供 Node 调用，可以基于[napi-rs](https://link.juejin.cn/?target=https%3A%2F%2Fnapi.rs%2F) 来实现
在这两种方式的选择上，主要取决于你是否需要完整地访问 Node API，WASM 出于安全性的考虑，对于 Node 能力的调用存在限制，那么你就应该选择 Node addons 的方式了。
基于 WASM
1.1 WASM 定义
WebAssembly（缩写为 wasm）是一种使用非 JavaScript 代码，并使其在浏览器中运行的方法。这些代码可以是 C、C++ 或 Rust 等。它们会被编译进你的浏览器，在你的 CPU 上以接近原生的速度运行。这些代码的形式是二进制文件，你可以直接在 JavaScript 中将它们当作模块来用。
￼
上图的左侧是用 C++实现的求递归的函数。中间是十六进制 的 Binary Code。右侧是指令文本。其实，中间的十六进制的 Binary Code 就是 WebAssembly。
总结：
    * WASM 是一种编译目标，不是用来给各位用手一行一行撸的代码， C、C++ 或 Rust 等都可以编译 成 WASM
    * WASM 模块可以被导入的到一个 Web / Node 中，并且暴露出供 JavaScript 使用的 WebAssembly 函数。
1.2 Rust 如何编译成 WASM
1.2.1 [wasm-pack](https://github.com/rustwasm/wasm-pack)
wasm-pack是一个构建、测试和发布 WASM 的 Rust CLI 工具，通过 wasm-pack 相关的命令可以管理构建过程，包括自动调用 wasm-bindgen 来生成胶水代码。
wasm-pack build --target nodejs
wasm-pack 会在项目中创建一个 pkg 目录，并包含以下内容
    * js 文件
    * wasm 文件
    * ts 声明文件
    * package.json 文件，所以打包出来的包是可以直接发 布 n pm 的
    * README 文件，是从你 的 Ru st 项 目中的 RE ADME 文件复制来的
￼
1.3 JS 如何调用 WASM
通过[wasm-pack](https://rustwasm.github.io/wasm-pack/installer/) 将 Rust 打包成可发布的 npm 包，js 通过调用 npm package 来调用编译好的 wasm 模块
￼
1.4 JS 和 Rust 交互
主要从 JS 如何调用 Rust 函数、数据交互两方面介绍
1.4.1 JS 调用 Rust 函数
[wasm-bindgen](https://github.com/rustwasm/wasm-bindgen)
[wasm-bindgen](https://github.com/rustwasm/wasm-bindgen)可以让WASM模块和Javascript模块进行更好的交互。通过使用宏（如 #[wasm_bindgen]）来注解Rust代码，这些宏会指导 wasm-bindgen 工具生成必要的JS胶水代码（glue code），以便Rust函数可以作为JavaScript函数来调用，或允许Rust代码调用JavaScript函数。
```
use wasm_bindgen::prelude::*;

// 从Web导入 `window.alert` 函数
#[wasm_bindgen]
extern "C" {
    fn alert(s: &str);
}

// 从Rust导出一个`greet`函数到Javascript，该函数会`alert`一条欢迎信息
#[wasm_bindgen]
pub fn greet(name: &str) {
    alert(&format!("Hello, {}!", name));
}
```
1.4.2 数据交互
js调用Rust函数进行函数传参时，我们需要通过json来处理，就需要用到serde和serde_json两个包
[Serde](https://www.rectcircle.cn/posts/rust-serde/)
Serde 是一个用于高效、通用地对 Rust 数据结构serializing(进行序列化)和deserializing(反序列化)的框架。该包提供了Serialize和Deserialize 两个trait。它本身不做转换的实际工作，实际工作是其它包实现的。我们可以结合serde，通过serde_json和rmp-serde将一种数据格式转换成JSON和MessagePack格式。
Serde_json
serde_json 是 serde 的一个插件，它提供了对 JSON 格式的支持。你可以使用 serde_json 将 JSON 数据反序列化为 Rust 数据结构，或者将 Rust 数据结构序列化为 JSON 格式。
serde_json = {version = "1", features = ["preserve_order"]}
serde = "1"
在 serde_json 中开启【preserve_order】这个 features，是因为 serde_json 在处理 json 数据时，Map 默认使用的是 BtreeMap，它对插入顺序不保证
// source是一个读取后json文件的信息

#[wasm_bindgen]
pub fn replace_json(source: &str, config: &str) -> String {
    let mut json_value: Map<String, Value> = serde_json::from_str(source).unwrap();
    let replacer = ConstReplacer::new(config);
    // 更新Json
    json_value[replacer.replaced_name] = replacer.replaced_value;

      // 将更新后的 json 结构体重新转换回 json 字符串
    let updated_json = serde_json::to_string_pretty(&json_value).unwrap();
    updated_json
}
如果想要让修改后JSON中的key顺序保持不变，那可以开启 preserve_order 特性
#[cfg(not(feature = "preserve_order"))]
type MapImpl<K, V> = BTreeMap<K, V>;
#[cfg(feature = "preserve_order")]
type MapImpl<K, V> = IndexMap<K, V>;
基于 Node addons
2.1 Nodejs addon 定义
node addon，即为 node 的扩展。
我们知道，Node.js 不适合 CPU 密集型计算的场景，通常的解决方法是用 C/C++ 编写 Node.js 的扩展（Addons）。以前只能用 C/C++，但是现在我们也可通过 Rus t 来编写我 们的 n ode 扩展。
    * .node结尾的文件
    * 是一个二进制文件
    * 是一个动态链接库 (Windows dll/Linux so/Unix dylib)
￼
2.2 使用[napi.rs](https://napi.rs/) 编写 node addons
napi-rs 是一个使用 Rust 构建预编译 Nodejs 插件的框架 ，通过这个框架我们可以使 用 Rust 来编写我们自己的原生 Nodejs 插件。
// 安装脚手架
yarn global add @napi-rs/cli

// 创建项目
napi new

// 构建
yarn build
build 完之后会新建三个文件
    * cool.darwin-x64.node是 Node.js addon 二进制文件
    * index.js自动生成的 JavaScript 绑定文件，它帮你从 addon 二进制中 export 出所有的东西，并且保证对 esm 与 CommonJS 的兼容。
    * index.d.ts是生成的 TypeScript 定义文件。
￼
index.js这个入口文件会根据操作系统和 CPU 架构来加载不同的二进制文件
2.3 js如何使用node addons
由于 napi-rs 已经帮助我们初始化了 CI 脚本，当你往 main 分支提交代码时，会自动触发 GitHub Actions 的操作，执行构建、测试、发布等步骤。
值得注意的是，在默认的脚本中，会根据当前的 commit 信息来判断是否需要发布，具体的判断逻辑如下:
    * case 1: 如果当前的 commit 信息只有 x.x.x(x 为数字)，则发布正式版本到 npm 上
    * case 2: 如果当前的 commit 信息在 case 1 的基础上增加了一些后缀内容，则发布 beta 版本到 npm 上
    * 其它情况不会发布。
在开发阶段和生产环境下调用node addons的策略有所不同
    * 本地开发阶段：直接通过yarn build，生成对应操作系统下的.node文件，然后加载项目目录下的.node文件
    * 生成环境：
暴露给用户安装使用的 package 将所有的 native package 作为optionalDependencies，然后通过package.json中的os与cpu字段，让npm/yarn/pnpm在安装的时候自动选择(其实是不符合系统要求的就安装失败了)安装哪一个 native package，比如
{
  "name": "@cwl/const-replace",
  "version": "0.5.0",
  "os": ["linux", "win32", "darwin"],
  "cpu": ["x64"],
  "optionalDependencies": {
    "@cwl/const-replace-darwin": "^0.5.0",
    "@cwl/const-replace-linux": "^0.5.0",
    "@cwl/const-replace-win32": "^0.5.0"
  }
}
{
  "name": "@cwl/const-replace-darwin",
  "version": "0.5.0",
  "os": ["darwin"],
  "cpu": ["x64"]
}
{
  "name": "@cwl/const-replace-linux",
  "version": "0.5.0",
  "os": ["linux"],
  "cpu": ["x64"]
}
比如我们将包发布到 npm 后，当用户执行 yarn add @cwl/const-replace 时，会自动下载 @cwl/const-replace-darwin-arm64 这个包，这个包里面包含了编译好的二进制文件，也就是 const-replace.darwin-arm64.node。这时候入口文件会去加载这个包里面的二进制文件。
￼
esbuild中就采用了上述的分发模式https://github.com/evanw/esbuild/blob/332727499e62315cff4ecaff9fa8b86336555e46/npm/esbuild/package.json#L20
￼
WASM 和 Node addons 对比
3.1 跨平台
WebAssembly 设计为一个通用的二进制格式，可以在任何支 持 WebAssembly 的平台上运行 ，包括 Web 浏览器和 Node.js 环境。WASM 模块编译一次，可以在几乎所有操作系统和硬件架构上运行。
napi-rs 天然不支持跨平台，它需要根据不同平台构建出不同的二进制文件。如果需要支持跨平台应用的话，需要集成跨平台的流水线。
￼
为了加载正确二进制文件，napi.rs会尝试加载该平台下所有可能的包
switch (platform) {
  case "android":
    // ...
    break;
  case "win32":
    // ...
    break;
  case "darwin":
    // ...
    break;
  default:
    throw new Error(`Unsupported OS: ${platform}, architecture: ${arch}`);
}
3.2 性能
Rust 原生 ≈ NativeAddon > WASM > JavaScript
以斐波那契数列为例：
n/耗时	Rust 原生	Native Addon	WASM	JS
43	0.97s	1.1s	2.9s	3.3s
44	1.55s	1.6s	4.6s	5.3s
45	2.5s	2.5s	7.4s	8.5s
3.3 安全性
由于WebAssembly 被限制运行在一个安全的沙箱执行环境中，没有直接访问宿主系统资源（如文件系统）的能力。WASM更关注的是安全性、可移植性、计算性能。
如果你的应用需要完全访问 Node.js API，执行系统级操作，或者需要使用 Node.js 的其他模块，那么 Node Addons 是更合适的选择。
3.4 应用
a. SWC
SWC 是一个基于 Rust 的可扩展平台，适用于下一代快速开发工具。它可用于编译和打包。
由于SWC是基于Rust写的，可是为什么我们通过JS也能调用swc/core的核心能力呢？？？？？？？？
这就是因为SWC通过napi-rs，编译成.node二进制文件来供JS调用
￼
b. Figma
Figma 虽然是网页应用，但它不是用 JavaScript 写的，而是用 Rust 写的，再编译成浏览器能理解的 WebAssembly 字节码格式，从而达到接近原生应用的性能。而另一个设计软件Sketch 是一个原生 MacOS 应用，只能在苹果电脑上安装运行，没有免费版。Figma 则是一个 Web 应用，只要有浏览器就能用，而且有免费版。这可能也是为啥Figma赢了Sketch
总结：
    * node addons的性能略高于 webassembly，且完整地访问 Node API，但不支持跨平台
    * webassembly 天然支持跨平台，但更适用于web场景，运行在沙箱环境中，自带安全性
三. 方案落地
在wenzhen-mini-app项目开始构建前，需要对一些变量的值进行统一替换
1. 替换多路复用环境的值
2. 替换 API_HOST，H5_HOST 等域名信息
3. CI 后上传代码作为开发版/体验版并生成预览二维码，需要改变版本号和版本发布信息
现有方案
1. 通过 readfile 读取对应所在变量的文件信息后，分别对 json 和 ts 文件进行处理
文件类型	处理
.ts 文件	通过正则表达式匹配变量名，对变量的值进行替换
.json 文件	通过 JSON.parse 将 json 文件转为对象，修改对象的 value，修改完后再 JSON.stringify 转为字符串
不足
1. 当面对复杂的代码结构时，难以直接通过正则表达式匹配到变量名和变量值进行替换。正则表达式如下：
const regex = new RegExp(`(${variableName}\\s*=\\s*)([^;]+)(;)`);
* 当变量连续声明时，中间使用,分隔而不是; 无法识别
* 当value中存在;正则分组匹配错误，导致替换失败
* ......
因为正则表达式不能正确理解 JavaScript 代码的复杂语法，可能会导致错误的匹配和替换。因此想通过 AST 分析器进行变量替换，它能更准确地理解代码的结构和含义。
技术选型
目前 JS 中 AST 分析器有
* @babel/core
* @swc/core
因为 swc 基于 Rust 编写，号称在单线程上比 Babel 快 20 倍，在四核上比 Babel 快 70 倍，所 以想通 过 swc 来进行 AST 的解析
1. 方案一：通过 js 调用 swc/core，在transform通过自定义的 swc-plugin 解析 ast
2. 方案二：rust 调 用 swc/core，并编 译成 wasm 供 js 调用
3. 方案三：rust调用swc/core，并编译成.node二进制文件供js调用
	使用成本	实现成本
方案一	前端项目中需要安装 swc/core 和自定义的 swc-plugin，接入麻烦	只需实现遍历 ast ，进行变量替换部分
方案二	可通过二进制文件或者 npm 包方式引入，接入简单	需实现 code -> ast -> code 全流程
方案三	可通过二进制文件或者 npm 包方式引入，但需要通过optionalDependencies配置好不同平台对应的npm包，CI较麻烦	需实现 code -> ast -> code 全流程
结论：采用方案二，先以最小成本验证Rust优化js工具函数的可行性。若后续能力需扩充可采用node addons的方式，逻辑和代码均可复用
具体实现
尝试搭建一个 Rust 项目，通过 serde_json 处理数据交互，swc/core 进行 AST 语法分析，wasm-pack 进行 Rust 项目的打包，具体步骤如下：
a. 创建项目
cargo new --lib const_replace
    * 因为我们要编译成wasm供js调用，需要将crate-type改成cdylib
[lib]
crate-type = ["cdylib"]
    * 引入swc_core，通过遍历ast，进行变量的修改
cargo add swc_core --features common,ecma_ast,ecma_parser,ecma_visit,ecma_codegen
swc 中核心库及作用如下：[swc_core - Rust](https://rustdoc.swc.rs/swc_core/index.html#)swc 中核心库及作用如下：[swc_core - Rust](https://rustdoc.swc.rs/swc_core/index.html#)
￼
￼
    * 因为 js 需要通过 json 传参给 wasm，在 Rust 中需要引入 serde,serde_json 来解析 json
serde_json = {version = "1", features = ["preserve_order"]}
serde = "1"
    * 我们需要让 wasm 和 js 进行交互，需要引入[wasm-bindgen](https://github.com/rustwasm/wasm-bindgen)
wasm-bindgen = "0.2.83"
    * 将需要导出的函数添加#[wasm_bindgen]过程宏，wasm-bindgen在编译时会生成对应的 glue code，从而在JS和webassembly之间调用函数
extern crate wasm_bindgen;
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn const_replace(source: &str, config: &str) -> Result<String, JsError> {
}
至此，我们项目所有的依赖如下：
```
[package]
name = "const-replace"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
swc_core = { version = "0.97.5", features = ["common", "ecma_ast", "ecma_parser", "ecma_visit", "ecma_codegen"] }
serde_json = {version = "1", features = ["preserve_order"]}
serde = "1"
wasm-bindgen = "0.2.83"
```
    * 通过[wasm-pack](https://rustwasm.github.io/wasm-pack/installer/) 将 Rust 打包成可发布的 npm 包，js 通过调用 npm package 来调用编译好的 wasm 模块
```
yarn global add wasm-pack
```
// 因为我们是通过node执行js文件，所以将target设置成nodejs，也可设置成为web
```
wasm-pack build --target nodejs
```
// js调用
const pkg = require('const-replace');
const content = pkg.const_replace(source, config)

---
此文自动发布于：<a href="https://github.com/chenwll/blog/issues/1" target="_blank">github issues</a>
